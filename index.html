<!DOCTYPE html>
<html>
<head>
<meta charset='utf-8'>
  <style>
	
		 body {
			font-family: "SUN7.21";
			width = 600px;
		}
		
		 h4 {	    
			 margin-block-start: .3em;
			 margin-block-end: .3em;
			 margin-inline-start: 0px;
			 margin-inline-end: 0px;
			 text-align: center;
		}
		  
		table {
			 border-width: 1px;
			 border-spacing: 0;
			 border-style: outset;
			 border-color: black;
			 border-collapse: separate;
			 background-color: white; 
			 font-size:14px;
			 font-family: 	Arial, Verdana, sans-serif;
			 /*font-family: "SUN7.21"; */
			 display:inline-table;
			 table-layout:fixed;
			 margin-bottom: 15px;
			 width:100%; 
			 empty-cells: show;
		}
			 
		 caption {
			 text-align: left;
			 margin-bottom: 1px;
			 font-size: 16px;
			 padding: 2px;
			 font-weight: bold;
		 }
			 
		 thead {
			 background-color: lightblue; 
			 font-weight: bold;
			 font-size: 14px;
		 }
		 
		 td {
			 border-width: 1px;
			 padding: 1px;
			 border-style: inset;
			 border-color: lightblue;
			/* width:7%;*/
			 /*min-width: 50px;*/
			font-size: 14px;
			 text-align: right; 
		 }
		 
			 /*Table Even Rows Styles*/
		 tbody tr:nth-child(even){
			 background-color: #efefef;
		 }
			 /*Table ODD Rows Styles*/
		 tbody tr:nth-child(odd){
			 background-color: #dfdfdf;
		 }
			 /*Table Row HOver Style*/
		 table tbody tr:hover{
			 background-color: #e5423f;
		 }
		
		:root {
			--sun-font: "SUN7.21";
			}
			
		.td0 {
			font-size: 32px;
		/*	font-family: "SUN7.21"; */
			font-family: var(--sun-font);
		}
		
		.input-group {
			vertical-align: middle;
			}
			
	</style>
</head>

<body>

-->
<h3>Choose the local(s) zip file(s)</h3>

<!-- <input type="file" id="xfileInput" onchange="loadFile()" name="file" accept=".ods"><br />
-->
<fieldset>
			<label for="fileInput"> <strong>ODS File:</strong></label>
			<input type="file" id="fileInput" onchange="loadFile()" accept=".ods, .csv">
			<br>
			<div class="input-group">
				<label for="sfont"> <strong>Enter Sun font name</strong></label>
				<input id='sfont' onChange='changeFont(true)' type='text' >
				<label for="xref1"> <strong>Enter search words separated by space</strong></label>
				<input id='xref1' onkeyup='search_Table("xref1")' type='text' style='width: 150px;'>
				<label for="xrefclear"> <strong>&nbsp &nbsp Clear </strong>
				<input id='xrefclear'  onclick='clearTable()' type='button'>
			</div>
		</fieldset>
		<div id="output"></div>
		<br>
		<br>
		<footer>
			<center>
			<p>&copy; Wilbur Zirk 2019</p>
			</center>
		</footer>
<script type="text/javascript" src="jszip.js"></script>
<script>

function loadFile() {
	var input, file, fr;

	if (typeof window.FileReader !== 'function') {
		bodyAppend("result", "The file API isn't supported on this browser yet.");
		return;
	}

	input = document.getElementById('fileInput');

	if (!input) {
		bodyAppend("result", "Um, couldn't find the fileinput element.");
	}
	else if (!input.files) {
		bodyAppend("result", "This browser doesn't seem to support the `files` property of file inputs.");
	} else if (!input.files[0]) {
		bodyAppend("result", "Please select a file before clicking 'Load'");
	} else {
		file = input.files[0];
		ext = file.name.split('.').pop().toUpperCase()
		console.log(ext, file.type);
		if (ext === "CSV") {
			handleFiles(file) 
		} else {
			 JSZip.loadAsync(file)                                   // 1) read the Blob
			.then(function(zip) {
				zip.forEach(function (relativePath, zipEntry) {  // 2) print entries
					console.log(zipEntry.name);
					//bodyAppend("result", zipEntry.name);
				});
					zip.files["content.xml"].async("string")
					.then(function (data) {
					//	console.log(data);
					//	Object.fromXML(data, true);
						//xml2table(data);
						var xmldata = parseXml(data);
						//console.log(xmldata);
					});
			}, function (e) {
				alert("Error reading " + f.name + ": " + e.message);
			});
		}
	}	
}	

function handleFiles(file) {
	// Check for the various File API support.
	if (window.FileReader) {
		// FileReader are supported.
		getAsText(file);
	} else {
		alert('FileReader are not supported in this browser.');
	}
}

function getAsText(fileToRead) {
	var reader = new FileReader();
	// Handle errors load
	reader.onload = loadHandler;
	reader.onerror = errorHandler;
	// Read file into memory as UTF-8      
	reader.readAsText(fileToRead);
}

function loadHandler(event) {
	var csv = event.target.result;
	//processData(csv);        
	var lines = csvToArray(csv);
	generateTable(lines);
}

function errorHandler(evt) {
	if(evt.target.error.name == "NotReadableError") {
		alert("Canno't read file !");
	}
}


function bodyAppend(elemID, text) {
	//console.log(elemID, text);
	var t = document.createTextNode(text);
	var br = document.createElement("br");
	 document.getElementById(elemID).appendChild(t);
	 document.getElementById(elemID).appendChild(br);
}

String.prototype.replaceAll = function (find, replace) {
    var str = this;
    return str.replace(new RegExp(find.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), 'g'), replace);
};

function xml2table(data) {
	var start = data.indexOf("<table:table ")
	var end = data.indexOf("</table:table>") + 14
	console.log(start, end);
	//data = data.substring(data.indexOf("<table:table "));
	//data = data.substring(0, data.indexOf("</table:table>"));
	data = data.substring(start, end);	
	var td = data.replace(/<table:table-cell office:value-type="string" calcext:value-type="string">/g,'<TD>');
	td = td.replace(/<table:table-row table:style-name="ro1">/g, '<TR>');
	td = td.replace(/<[/]table:table-cell>/g,'</TD>');
	td = td.replace(/<[/]table:table-row>/g,'</TR>');
	td = td.replace(/<text:p>/g,'');
	td = td.replace(/<[/]text:p>/g,'');
	console.log(td);
	document.getElementById("tablebody").innerHTML = td;
	//document.getElementsByTagName("/thead").innerHTML = td;
}

function parseXml(xmlStr) {
	//return new window.DOMParser().parseFromString(xmlStr, "text/xml");
    xmlStr = xmlStr.replace(/<text:s[/]>/g, "");
	parser = new DOMParser();
	xmlDoc = parser.parseFromString(xmlStr,"text/xml");
	a = xmlDoc.getElementsByTagName("table:table")[0]
	b = a.childNodes;
	var ih = ""
	var tableArray = [];
	 for (var i = 0; i < b.length; i++) {
		c = b[i];
		d = c.childNodes;
		var line = "";
		var row = [];
		if (d.length > 0) {
			for (var j = 0; j < d.length; j++) {
			//	line = line + d[j].firstChild.innerHTML+',';
				if (d[j].firstChild) {
					//console.log(d[1].firstChild.innerHTML);
					line = line + d[j].firstChild.innerHTML+'!';
					row.push(d[j].firstChild.innerHTML);
				}
			}
			ih = ih + line+'<br>';
			tableArray.push(row);
		}
		//if (i > 19) break;
	} 
	console.log(tableArray);
	//document.getElementById("tablebody").innerHTML = ih;
	generateTable(tableArray);
}

function generateTable(lines){
	//Clear previous data
	document.getElementById("output").innerHTML = "";
	var table = document.createElement("table");
	table.id = "searchtable";
	var len = 0;
	for (var i = 0; i < lines.length; i++) {
	  // find longest row
		if (lines[i].length > len) {
			len = lines[i].length;
		}
	}
	for (var i = 0; i < lines.length; i++) {
		var row = table.insertRow(-1);
		//console.log(lines[i].length);
		//for (var j = 0; j < lines[i].length; j++) {
		for (var j=0; j< len; j++) {
			var td = row.insertCell(-1);
			if (j ===0) td.className = 'td0';
			// if missing cells create them
			if (lines[i][j]) text = lines[i][j];
			else text = "";
			td.appendChild(document.createTextNode(text));
		}
	}
	document.getElementById("output").appendChild(table);
}

function csvToArray(text) {
    let p = '', row = [''], ret = [row], i = 0, r = 0, s = !0, line;
   
   for (line of text) {
        if ('"' === line) {
            if (s && line === p) {
				row[i] += line;
			}
            s = !s;
        } else if (',' === line && s) {
      		line = row[++i] = '';
		} else if ('\n' === line && s) {
            if ('\r' === p) {
				row[i] = row[i].slice(0, -1);
			}
            row = ret[++r] = [line = '']; i = 0;
        } else {
			row[i] += line;
		}
        p = line;
    }
    return ret;
};

function search_Table(){
	var input = document.getElementById('xref1').value.toUpperCase();
	var filter =  input.split(' '); 
	table = document.getElementById("searchtable");
	tr = table.getElementsByTagName("tr");
	//console.log('search ', xref, filter, tr.length);
	for (i = 0; i < tr.length; i++) {
		//console.log(i, filter1, filter2, tr[i].style.display);
		td = tr[i].getElementsByTagName("td") ; 
		//for(j=0 ; j < td.length ; j++) {
		var text = "";
		for(j=0 ; j < td.length ; j++) {
			 //var j = 3;
			  let tdata = td[j] ;
			  if (tdata) {
				 text = text + tdata.innerHTML.toUpperCase();
			  }
		  }
					//var text = tdata.innerHTML.toUpperCase();
					var found =true;
					for(var f = 0; f < filter.length; f++) {
						if (text.indexOf(filter[f])  === -1) { 
							found = false;
						}
					}
					//console.log(i, input1, td[1].innerHTML, found)
					if (found) {
							tr[i].style.display = "";
							//break ; 
					} else {
							tr[i].style.display = "none";
					}
			}
		//}
	//}
}

function clearTable() {
    var input, filter, found, srchtable, tr, td, i, j;
    document.getElementById('xref1').value = "";
	document.getElementById('fileInput').value = ""; 
	document.getElementById('output').innerHTML = ""; 
	console.log("clearall");
    //filter = input.value.toUpperCase();
    srchtable = document.getElementById("searchtable");
    tr = srchtable.getElementsByTagName("tr");
	if (!tr) {
		for (i = 0; i < tr.length; i++) {
				tr[i].style.display = "";
		}
	}
}

function listCookies() {
         	var theCookies = document.cookie.split(';');
			console.log(theCookies);
         	var aString = '';
         	for (var i = 1 ; i <= theCookies.length; i++) {
         		aString += i + ' ' + theCookies[i-1] + "\n";
         	}
         	return aString;
         }
		 
         cookie = {
         	set: function (name, value, days) {
         		if (days) {
         			var date = new Date();
         			date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
         			var expires = "; expires=" + date.toGMTString();
         		} else {
         			var expires = "";
				}	
         		document.cookie = name + "=" + JSON.stringify(value) + expires + "; path=/";
         		console.log('set', name, value,"=" + JSON.stringify(value) + expires);
         	},
         
         	get : function(name){
         		var nameEQ = name + "=", ca = document.cookie.split(';');
         		for(var i=0;i < ca.length;i++) {
         		  var c = ca[i];
         		  while (c.charAt(0)==' ') c = c.substring(1,c.length);
         			if (c.indexOf(nameEQ) == 0) {
         			  console.log('get',nameEQ,JSON.parse(c.substring(nameEQ.length,c.length)));
         			  return  JSON.parse(c.substring(nameEQ.length,c.length));
         			}
         		}
         		return null;
         	}
         
         }

  /**
 * Usage: d = new FontDetector();
 *        d.detect('font name');
 */
var FontDetector = function() {
console.log('fontdetector');
    // a font will be compared against all the three default fonts.
    // and if it doesn't match all 3 then that font is not available.
    var baseFonts = ['monospace', 'sans-serif', 'serif'];

    //we use m or w because these two characters take up the maximum width.
    // And we use a LLi so that the same matching fonts can get separated
    var testString = "mmmmmmmmmmlli";

    //we test using 72px font size, we may use any size. I guess larger the better.
    var testSize = '72px';

    var h = document.getElementsByTagName("body")[0];

    // create a SPAN in the document to get the width of the text we use to test
    var s = document.createElement("span");
    s.style.fontSize = testSize;
    s.innerHTML = testString;
    var defaultWidth = {};
    var defaultHeight = {};
    for (var index in baseFonts) {
        //get the default width for the three base fonts
        s.style.fontFamily = baseFonts[index];
        h.appendChild(s);
        defaultWidth[baseFonts[index]] = s.offsetWidth; //width for the default font
        defaultHeight[baseFonts[index]] = s.offsetHeight; //height for the defualt font
        h.removeChild(s);
    }

    function detect(font) {
	console.log('detect',font);
        var detected = false;
        for (var index in baseFonts) {
            s.style.fontFamily = '"' + font + '"' + ',' + baseFonts[index]; // name of the font along with the base font for fallback.
            h.appendChild(s);
            var matched = (s.offsetWidth != defaultWidth[baseFonts[index]] || s.offsetHeight != defaultHeight[baseFonts[index]]);
            h.removeChild(s);
            detected = detected || matched;
        }
        return detected;
    }

    this.detect = detect;
};
 
 function changeFont(setCookie) {
	var fval = document.getElementById('sfont').value;
	d = new FontDetector().detect(fval);
	console.log(d);
	//console.log(d.detect(fval));
	if (d) {
		fval ='"'+fval+'"';
		console.log('changefont',fval);
		document.documentElement.style.setProperty('--sun-font', fval);
		if (setCookie) {
		  cookie.set('font', fval);
		}
	} else {
		alert("Font not found");
	}
}


document.getElementById('sfont').value = "";
document.getElementById('xref1').value = ""; 
document.getElementById('fileInput').value = ""; 
document.getElementById('output').innerHTML = ""; 

console.log(listCookies());
var fnt = cookie.get("font").replace (/(^")|("$)/g, ''); // remove quotes

console.log(fnt);
document.getElementById('sfont').value = fnt;
changeFont(false);

</script>
</body>
</html>
